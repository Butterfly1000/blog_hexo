---
title: R系列-1
date: 2021-11-24 19:47:33
tags: Redis
---

> 缓存雪崩 (大量key失效，导致大量访问，犹如雪崩)

在`高并发`场景下，大量缓存key在`同一时间失效`，造成大量请求直接落在数据库上，导致数据库宕机。

解决方案:

- 随机设置key失效时间，避免大量key集体失效。

```
setRedis（Key，value，time + Math.random() * 10000）；
```

- 若是集群部署，可将热点数据均匀分布在不同的Redis库中也能够避免key全部失效问题
- 不设置过期时间
- 跑定时任务，在缓存失效前刷进新的缓存



> 缓存穿透(绕过redis，实现穿透)

`redis缓存`和`数据库`中没有相关数据(例用户直接携带`id<=0`的参数不断发起请求)，redis中没有这样的数据，`无法进行拦截`，直接被穿透到`数据库`，导致数据库压力过大宕机。

### 解决方案

- 对不存在的数据缓存到redis中，设置key，value值为null(不管是数据未null还是系统bug问题)，并设置一个短期过期时间段，避免过期时间过长影响正常用户使用。
- 拉黑该IP地址
- 对参数进行校验，不合法参数进行拦截`(认为最有效的之一)`
- 布隆过滤器 将所有可能存在的数据哈希到一个足够大的bitmap(位图)中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。`(认为最有效的之一)`



> 缓存击穿 (对一个点高频打击，然后穿透)

`某一个`热点key，在不停地扛着高并发，当这个热点key在`失效的一瞬间`，持续的高并发访问就`击破缓存`直接访问数据库，导致数据库宕机。

### 解决方案

- 设置热点数据"永不过期"

- 加上互斥锁：上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它

  其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后将数据放到redis缓存起来。后面的线程进来发现已经有缓存了，就直接走缓存

## 最后总结

雪崩是`大面积`的key缓存失效；穿透是redis里`不存在`这个缓存key；击穿是redis`某一个热点`key突然失效，最终的受害者都是数据库。

## 思考

`未雨绸缪`：将redis、MySQL等搭建成高可用的集群，防止单点。

`亡羊补牢`：服务中进行限流 + 降级，防止MySQL被打崩溃。

`重振旗鼓`：Redis 持久化 RDB+AOF，宕机重启，自动从磁盘上加载数据，快速恢复缓存数据

[原文链接](https://juejin.cn/post/6872536898003271687)
